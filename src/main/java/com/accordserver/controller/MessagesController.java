package com.accordserver.controller;

import com.accordserver.ResponseMessage;
import com.accordserver.accessingdatamysql.categories.Categories;
import com.accordserver.accessingdatamysql.categories.CategoriesRepository;
import com.accordserver.accessingdatamysql.channels.Channels;
import com.accordserver.accessingdatamysql.channels.ChannelsRepository;
import com.accordserver.accessingdatamysql.messages.Messages;
import com.accordserver.accessingdatamysql.messages.MessagesRepository;
import com.accordserver.accessingdatamysql.server.Server;
import com.accordserver.accessingdatamysql.server.ServerRepository;
import com.accordserver.accessingdatamysql.user.User;
import com.accordserver.accessingdatamysql.user.UserRepository;
import com.accordserver.webSocket.SystemWebSocketHandler;
import com.github.cliftonlabs.json_simple.JsonArray;
import com.github.cliftonlabs.json_simple.JsonObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

import static com.accordserver.util.Constants.*;

@RestController
public class MessagesController {

    // This means to get the bean called messagesRepository,... . Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    private MessagesRepository messagesRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ServerRepository serverRepository;

    @Autowired
    private CategoriesRepository categoriesRepository;

    @Autowired
    private ChannelsRepository channelsRepository;

    @Autowired
    private SystemWebSocketHandler systemWebSocketHandler;

    /**
     * Gets all messages of the given channel, category and server
     * WHO CAN DO? -> ALL SERVER USER
     *
     * @param userKey    key of the user
     * @param serverId   id of the server where the messages should be returned
     * @param categoryId id of the category where the messages should be returned
     * @param channelId  id of the channel where the messages should be returned
     * @param timestamp  time when the message was sent
     * @return json list of all channels of the given category
     */
    @GetMapping("/servers/{serverId}/categories/{categoryId}/channels/{channelId}/messages")
    public @ResponseBody
    ResponseMessage getMessages(@RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId, @PathVariable("categoryId") String categoryId, @PathVariable("channelId") String channelId, @RequestParam String timestamp) {

        List<Messages> MessagesList = (List<Messages>) messagesRepository.findByChannelId(channelId);

        JsonArray responseMessagesDataList = new JsonArray();
        // put all messages
        for (Messages messages : MessagesList) {
            JsonObject responseMessageData = new JsonObject();
            responseMessageData.put("id", messages.getId());
            responseMessageData.put("channel", channelId);
            responseMessageData.put("timestamp", messages.getTimestampMessage());
            responseMessageData.put("from", messages.getFromUser());
            responseMessageData.put("text", messages.getContent());

            responseMessagesDataList.add(responseMessageData);
        }

        return new ResponseMessage(SUCCESS, "", responseMessagesDataList);
    }

    /**
     * update message
     * WHO CAN DO? -> ONLY MESSAGE OWNER/FROM
     *
     * @param userKey key of the user
     * @return json list of all server
     */
    @PutMapping("/servers/{serverId}/categories/{categoryId}/channels/{channelId}/messages/{messageId}")
    public @ResponseBody
    ResponseMessage updateMessage(@RequestBody Map<String, Object> data, @RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId, @PathVariable("categoryId") String categoryId, @PathVariable("channelId") String channelId, @PathVariable("messageId") String messageId) {
        User currentUser = userRepository.findByUserKey(userKey);

        Messages currentMessage = messagesRepository.findById(messageId).get();

        // if message is from the user who wants to edit
        if (currentUser.getName().equals(currentMessage.getFromUser())) {

            Server currentServer = serverRepository.findById(serverId).get();
            Categories currentCategory = categoriesRepository.findById(categoryId).get();
            Channels currentChannel = channelsRepository.findById(channelId).get();


            String newMessageText = data.get("text").toString();

            // update message
            currentMessage.setContent(newMessageText);
            messagesRepository.save(currentMessage);

            // send webSocket message
            systemWebSocketHandler.sendMessageUpdated(currentServer, currentCategory, currentChannel, currentMessage);

            // return json
            JsonObject responseMessageData = new JsonObject();
            responseMessageData.put("id", currentMessage.getId());
            responseMessageData.put("channel", currentChannel.getId());
            responseMessageData.put("timestamp", currentMessage.getTimestampMessage());
            responseMessageData.put("from", currentMessage.getFromUser());
            responseMessageData.put("text", currentMessage.getContent());

            return new ResponseMessage(SUCCESS, "", responseMessageData);
        } else {
            return new ResponseMessage(FAILED, "This is not your message!", new JsonObject());
        }
    }

    /**
     * deletes a message
     * WHO CAN DO? -> PERSON WHO WRITES THE MESSAGE
     *
     * @param userKey key of the user
     * @return json list of all server
     */
    @DeleteMapping("/servers/{serverId}/categories/{categoryId}/channels/{channelId}/messages/{messageId}")
    public @ResponseBody
    ResponseMessage deleteMessage(@RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId, @PathVariable("categoryId") String categoryId, @PathVariable("channelId") String channelId, @PathVariable("messageId") String messageId) {
        User currentUser = userRepository.findByUserKey(userKey);

        Server currentServer = serverRepository.findById(serverId).get();
        Categories currentCategory = categoriesRepository.findById(categoryId).get();
        Channels currentChannel = channelsRepository.findById(channelId).get();
        Messages currentMessage = messagesRepository.findById(messageId).get();

        if (currentMessage.getFromUser().equals(currentUser.getName())) {

            // delete message by channel message list (because of one-to-many association)
            currentChannel.removeMessage(currentMessage);
            channelsRepository.save(currentChannel);

            // send webSocket message
            systemWebSocketHandler.sendMessageDeleted(currentServer, currentCategory, currentChannel, currentMessage, currentUser);

            // return json
            JsonObject channelData = new JsonObject();
            channelData.put("id", currentMessage.getId());
            channelData.put("channel", currentChannel.getId());
            channelData.put("timestamp", currentMessage.getTimestampMessage());
            channelData.put("from", currentMessage.getFromUser());
            channelData.put("text", currentMessage.getContent());

            return new ResponseMessage(SUCCESS, "", channelData);
        } else {
            return new ResponseMessage(FAILED, "This is not your message!", new JsonObject());
        }
    }
}