package com.accordserver.controller;

import com.accordserver.ResponseMessage;
import com.accordserver.accessingdatamysql.server.Server;
import com.accordserver.accessingdatamysql.server.ServerRepository;
import com.accordserver.accessingdatamysql.user.User;
import com.accordserver.accessingdatamysql.user.UserRepository;
import com.accordserver.accessingdatamysql.învites.Invites;
import com.accordserver.accessingdatamysql.învites.InvitesRepository;
import com.accordserver.webSocket.SystemWebSocketHandler;
import com.github.cliftonlabs.json_simple.JsonArray;
import com.github.cliftonlabs.json_simple.JsonObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

import static com.accordserver.util.Constants.*;

@RestController
public class InvitesController {

    // This means to get the bean called invitesRepository,... . Which is auto-generated by Spring, we will use it to handle the data
    @Autowired
    private InvitesRepository invitesRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ServerRepository serverRepository;

    @Autowired
    private SystemWebSocketHandler systemWebSocketHandler;

    /**
     * creates a new invite
     *
     * @param userKey key of the user
     * @return rest answer
     */
    @PostMapping("/servers/{serverId}/invites")
    public @ResponseBody
    ResponseMessage createInvite(@RequestBody Map<String, Object> data, @RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId) {
        User currentUser = userRepository.findByUserKey(userKey);
        Server currentServer = serverRepository.findById(serverId).get();

        if (currentServer.getOwner().equals(currentUser.getId())) {
            // create invite and save it
            Invites newInvite = new Invites(data.get("type").toString(), currentServer);

            if (newInvite.getType().equals(COUNT)) {
                // with limit
                newInvite.setMax((Integer) data.get("max"));

                currentServer.setInvites(newInvite);

                serverRepository.save(currentServer);

                // send response
                JsonObject responseData = new JsonObject();
                responseData.put("id", newInvite.getId());
                responseData.put("link", newInvite.getLink());
                responseData.put("type", newInvite.getType());
                responseData.put("max", newInvite.getMax());
                responseData.put("current", newInvite.getCurrent());
                responseData.put("server", currentServer.getId());
                return new ResponseMessage(SUCCESS, "", responseData);
            } else {
                // with temp
                // add temp timer?!

                currentServer.setInvites(newInvite);

                serverRepository.save(currentServer);

                // send response
                JsonObject responseData = new JsonObject();
                responseData.put("id", newInvite.getId());
                responseData.put("link", newInvite.getLink());
                responseData.put("type", newInvite.getType());
                responseData.put("server", currentServer.getId());
                return new ResponseMessage(SUCCESS, "", responseData);
            }
        } else {
            return new ResponseMessage(FAILED, "This is not your server!", new JsonObject());
        }
    }

    /**
     * Gets all invites of the given server
     * WHO CAN DO? -> ONLY OWNER
     *
     * @param userKey  key of the user
     * @param serverId id of the server where the invites should be returned
     * @return json list of all invites of the given server
     */
    @GetMapping("/servers/{serverId}/invites")
    public @ResponseBody
    ResponseMessage getInvites(@RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId) {
        User currentUser = userRepository.findByUserKey(userKey);
        Server currentServer = serverRepository.findById(serverId).get();

        if (currentServer.getOwner().equals(currentUser.getId())) {
            List<Invites> invitesList = (List<Invites>) invitesRepository.findByServerId(serverId);

            JsonArray responseInvitesDataList = new JsonArray();
            for (Invites invite : invitesList) {
                JsonObject responseInviteData = new JsonObject();
                responseInviteData.put("id", invite.getId());
                responseInviteData.put("link", invite.getLink());
                responseInviteData.put("type", invite.getType());
                responseInviteData.put("max", invite.getMax());
                responseInviteData.put("current", invite.getCurrent());
                responseInviteData.put("server", currentServer.getId());

                responseInvitesDataList.add(responseInviteData);
            }

            return new ResponseMessage(SUCCESS, "", responseInvitesDataList);
        } else {
            return new ResponseMessage(FAILED, "This is not your server!", new JsonObject());
        }
    }

    /**
     * join an invitation
     *
     * @param userKey  key of the user
     * @param serverId where the user what to join
     * @param inviteId id of the invitation
     * @return rest answer
     */
    @PostMapping("/servers/{serverId}/invites/{inviteId}")
    public @ResponseBody
    ResponseMessage joinInvitation(@RequestBody Map<String, Object> data, @RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId, @PathVariable("inviteId") String inviteId) {
        User currentUser = userRepository.findByUserKey(userKey);
        Server currentServer = serverRepository.findById(serverId).get();

        if (currentUser.getName().equals(data.get("name").toString()) && currentUser.getPassword().equals(data.get("password").toString())) {

            if (invitesRepository.findById(inviteId).isPresent()) {
                Invites currentInvite = invitesRepository.findById(inviteId).get();

                // set new member and save it
                currentServer.setUser(currentUser);
                currentUser.setServers(currentServer);
                serverRepository.save(currentServer);
                userRepository.save(currentUser);

                if (currentInvite.getType().equals(COUNT)) {
                    // increase count by 1 and delete invite if max count is reached
                    currentInvite.setCurrent(currentInvite.getCurrent() + 1);
                    if (currentInvite.getCurrent() == currentInvite.getMax()) {
                        invitesRepository.delete(currentInvite);
                    } else {
                        invitesRepository.save(currentInvite);
                    }
                }

                // send webSocket message
                systemWebSocketHandler.sendUserArrived(currentServer, currentUser);

                // send response
                return new ResponseMessage(SUCCESS, "Successfully arrived at server", new JsonObject());
            } else {
                return new ResponseMessage(FAILED, "Invitation is invalid or expired!", new JsonObject());
            }
        } else {
            return new ResponseMessage(FAILED, "Wrong username and/or password!", new JsonObject());
        }
    }

    /**
     * delete invitation
     * WHO CAN DO? -> ONLY OWNER
     *
     * @param userKey key of the user
     * @return json list of all server
     */
    @DeleteMapping("/servers/{serverId}/invites/{inviteId}")
    public @ResponseBody
    ResponseMessage deleteInvitation(@RequestHeader(value = USER_KEY) String userKey, @PathVariable("serverId") String serverId, @PathVariable("inviteId") String inviteId) {
        User currentUser = userRepository.findByUserKey(userKey);

        Server currentServer = serverRepository.findById(serverId).get();
        Invites currentInvitation = invitesRepository.findById(inviteId).get();

        if (currentServer.getOwner().equals(currentUser.getId())) {

            // delete invitation
            invitesRepository.delete(currentInvitation);

            // return json
            JsonObject invitationData = new JsonObject();
            invitationData.put("id", currentInvitation.getId());
            invitationData.put("link", currentInvitation.getLink());
            invitationData.put("type", currentInvitation.getType());
            invitationData.put("max", currentInvitation.getMax());
            invitationData.put("current", currentInvitation.getCurrent());
            invitationData.put("server", currentServer.getId());

            return new ResponseMessage(SUCCESS, "", invitationData);
        } else {
            return new ResponseMessage(FAILED, "This is not your server!", new JsonObject());
        }
    }
}